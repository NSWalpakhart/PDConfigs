NGINX BALANCER

Round Robin — это метод балансировки нагрузки, при котором каждому серверу в кластере предоставляется равная возможность обрабатывать запросы.
Например, если у вас есть три вышестоящих сервера, A, B и C, то балансировщик нагрузки сначала распределит нагрузку на A, затем на B и, наконец, на C, прежде чем перераспределить нагрузку на A.

Weighted Round Robin — один из самых популярных методов балансировки нагрузки, используемых сегодня.
Этот метод предполагает присвоение веса каждому серверу, а затем распределение трафика между серверами на основе этих весов.

Метод наименьшего числа соединений (Least Connection) — это популярная техника, используемая для равномерного распределения рабочей нагрузки между несколькими серверами. Метод работает путём маршрутизации каждого нового запроса на соединение — на сервер с наименьшим количеством активных соединений.

Least Connection с добавлением веса
Данный метод используется для распределения рабочей нагрузки между несколькими вычислительными ресурсами (такими как серверы) с целью оптимизации производительности и минимизации времени отклика.

Метод балансировки IP Hash использует алгоритм хэширования для определения того, какой сервер должен получить каждый из входящих пакетов. Это полезно, когда за одним IP-адресом находится несколько серверов, и вы хотите убедиться, что каждый пакет с IP-адреса клиента направляется на один и тот же сервер.


Чтобы пометить вышестоящий сервер как недоступный, нам нужно определить два параметра в директиве upstream: failed_timeout и max_fails.

failed_timeout задаёт время, в течение которого должно произойти определённое количество неудачных попыток, чтобы сервер был помечен как недоступный.

max_fails задаёт количество неудачных попыток.






REGEX

Если по простому, регулярка- это некий шаблон, по которому фильтруется текст. Мы можем написать нужный нам шаблон (регулярку) и таким образом искать в тексте необходимые нам символы, слова и т.д. Также их используют, например, при заполнении поля E-mail на различных сайтах, т.е. создают шаблон по типу: someEmail@gmail.com. Это я взял как пример, не более. Теперь, разобравшись, что это, приступим к изучению. Обещаю, скучно не будет)

# -------------------------------------------------- -------------------------------------------------- ----------------------------------------
# Модификатор порядка поиска Описание Типа совпадения Остановка поиска при совпадении
# -------------------------------------------------- -------------------------------------------------- ----------------------------------------
# 1-й = URI должен точно соответствовать указанному шаблону. Простая строка Да.
# 2nd ^~ URI должен начинаться с указанного шаблона Простая строка Да
# 3-й (нет) URI должен начинаться с указанного шаблона. Простая строка. Нет.
# 4-й ~ URI должен соответствовать указанному Rx Perl-Compatible-Rx Yes (первое совпадение) с учетом регистра.
# 4-й ~* URI должен соответствовать указанному Rx Perl-Compatible-Rx Yes (первое совпадение) без учета регистра.
# Н/Д @ Определяет именованный блок местоположения. Простая строка Да
# -------------------------------------------------- -------------------------------------------------- ----------------------------------------

# -------------------------------------------------- ---------------------------------------
# () : Группа/группа захвата, захват среднего совпадения и сохранение/вывод/использование того, что совпало
# шаблон внутри (). режим скобок по умолчанию — «группа захвата», а (?:)
# — группа без захвата. пример (?:a|b) соответствует a или b в режиме без захвата
# -------------------------------------------------- ---------------------------------------
# ?: : Группа без захвата
# ?= : Позитивный взгляд вперед
# ?! : означает негативный прогноз вперед (не соответствует следующему...)
# ?<= : для позитивного взгляда назад
# ?<! : означает негативный взгляд назад
# -------------------------------------------------- ---------------------------------------


# -------------------------------------------------- ---------------------------------------
# ~ : Включить режим регулярного выражения для местоположения (в регулярном выражении ~ означает совпадение с учетом регистра)
# ~* : совпадение без учета регистра
# | : Или
# () : Сопоставить группу или оценить содержимое ()
# $: выражение должно находиться в конце вычисляемого текста
# (после совпадения нет символов/текста) $ обычно используется в конце регулярного выражения
# выражение местоположения.
# ? : Проверка отсутствия или одного появления предыдущего символа, например jpe?g.
# ^~ : совпадение должно быть в начале текста. Обратите внимание, что nginx не будет работать.
# любое дальнейшее совпадение с регулярным выражением, даже если доступно другое совпадение
# (проверьте таблицу выше); ^ указывает, что совпадение должно быть в начале
# текст uri, а ~ указывает режим соответствия регулярному выражению.
# пример (местоположение ^~ /realestate/.*)
# Оценка Nginx именно такая, поскольку не проверяет расположение регулярных выражений, если это
# местоположение — это совпадение с самым длинным префиксом.
# = : точное совпадение, без подпапок (расположение = /)
# ^ : соответствует началу текста (напротив $). Сам по себе ^ является
# ярлык для всех путей (так как все они имеют начало).
# .* : Соответствует нулю, одному или нескольким вхождениям любого символа
# \ : перейти к следующему символу
# . : Любой символ
# * : Соответствует нулю, одному или нескольким вхождениям предыдущего символа.
# ! : Нет (негативный прогноз вперед)
# {} : Сопоставить определенное количество вхождений, например. [0-9]{3} соответствует 342, но не 32
# {2,4} длина совпадения 2, 3 и 4
# + : Сопоставить одно или несколько вхождений предыдущего символа.
# [] : Сопоставить любой символ внутри
# -------------------------------------------------- -------------------------------------------








PROXY

Основное различие между ними заключается в том, что прямой прокси-сервер используется клиентом, таким как веб-браузер, тогда как обратный прокси-сервер используется сервером, таким как веб-сервер. Прямой прокси-сервер может находиться в той же внутренней сети, что и клиент, или в Интернете.

Прямой прокси-сервер может использоваться клиентом для обхода ограничений брандмауэра для посещения веб-сайтов, которые заблокированы школой, правительством, компанией и т. д. Если веб-сайт заблокировал диапазон IP-адресов от посещения веб-сайта, то человек в этом диапазоне IP-адресов может использовать пересылку прокси, чтобы скрыть реальный IP клиента, чтобы человек мог зайти на сайт и, возможно, оставить спам-комментарии. Однако прямой прокси может быть обнаружен администратором сайта.

Обратный прокси-сервер в основном используется администраторами серверов для обеспечения балансировки нагрузки и высокой доступности. Веб-сайт может иметь несколько веб-серверов за обратным прокси-сервером. Обратный прокси-сервер принимает запросы из Интернета и перенаправляет эти запросы на один из веб-серверов. Большинство посетителей не знают, что веб-сайты используют обратный прокси-сервер, потому что им обычно не хватает знаний и инструментов для его обнаружения, или они просто не заботятся об этом. 







SSL

Определение симметричного шифрования

При симметричном шифровании данные шифруются и дешифруются одним и тем же секретным ключом, который используется получателем и отправителем. Это означает, что ключ должен быть передан получателю безопасным способом, чтобы только он и никто другой не имели к нему доступа. Это высокоскоростной метод шифрования.

Определение асимметричного шифрования

Более сложный процесс, асимметричное шифрование, работает с использованием двух разных, но математически связанных ключей, открытого и закрытого ключей, для шифрования и дешифрования данных. Открытый ключ, доступ к которому может получить любой, используется для шифрования данных. Для расшифровки сообщения можно использовать только  закрытый ключ который находится на сервере.


В то время как симметричное шифрование использует один общий ключ для шифрования и дешифрования данных, асимметричное использует два отдельных ключа. Симметричное шифрование использует более короткие ключи (обычно 128 или 256 бит). Для сравнения, асимметричные ключи намного длиннее (иногда 2048 бит или больше). Вот почему асимметричное шифрование занимает немного больше времени, чем симметричное.

Однако, хотя симметричное шифрование является более быстрым и простым процессом, оно более уязвимо для угроз безопасности из-за того, что общий ключ хранится в секрете. Между тем, асимметричное шифрование может быть более сложным и, как следствие, более медленным процессом, но в конечном итоге это гораздо более безопасный метод шифрования. В отличие от симметричного шифрования, он может аутентифицировать личность, что делает его идеальным для сообщений, отправляемых между двумя сторонами, ранее неизвестными друг другу (например, пользователь, впервые посещающий веб-сайт).

С другой стороны, симметричное шифрование, как правило, в основном используется во внутренней среде ИТ-безопасности, где секретный ключ может безопасно и надежно совместно использоваться между получателем и отправителем.


